---
title: "String manipulation in R"
author: "Atreya"
date: "4 March 2018"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE,warning=FALSE}
library(stringr)
library(babynames)
library(dplyr)
library(rebus)
```
### Defining strings

Defning string in R is a bit tricky and there are some conventions to handle different kind of scenarios.

```{r}
l1 <- "I said Hi!" # No quotes in the strng, use double quotes
l2 <- 'I said "Hi"'# Double quotes in the string, use single quotes
l3 <- "I'd said \"Hi!\"" #Doubles and single quotes in the string, use double quotes and escape sequences
lines <- c(l1,l2,l3)
writeLines(lines,sep="\n")
```

Numbers can be converted to strings using `format` and `formatC`. The numbers can be converted to two types; fixed and scientific.
```{r}
nums <- c(19800000000000000000000000000,0.000000000000000000000023)
format(nums,scientific = TRUE)
format(nums,scientific = FALSE)
formatC(nums,format = "f")#fixed
formatC(nums,format = "e")#scientific
formatC(nums,format = "g")#scientific only if it saves space
```

The format function works in a tricky way. When the representation is scientific, the digits argument is the number of digits before the exponent. When the representation is fixed, digits controls the significant digits used for the smallest (in magnitude) number. Each other number will be formatted to match the number of decimal places in the smallest number. This means the number of decimal places you get in your output depends on **all** the values you are formatting!

```{r}
percent_change  <- c(4, -1.91, 3.00, -5.002)
income <-  c(72.19, 1030.18, 10291.93, 1189192.18)
p_values <- c(0.12, 0.98, 0.0000191, 0.00000000002)
format(percent_change,digits = 2)
format(income,digits = 2)
format(p_values,digits = 2)
```

`paste` can be used to join strings
```{r}
paste(c("Hey","How are"),c("you!","you?"))
paste(c("Hey","How are"),c("you!"),sep="*",collapse = ", ")
```

### Stringr 

* Built on `stringi`, easy to learn
* All functions start with `str_`, concise and consistent
* All stringr functions use a vector of strings as a first argument

```{r}
#difference between str_c and paste
s1<- c("cards",NA,NA)
s_paste_1 <- paste(c("", "", "and "), s1, sep = "")
s_paste_2 <- paste(c("", "", "and "), s1, collapsse = ", ")
s_str_1 <- str_c(c("", "", "and "), s1, sep = "")
s_str_2 <- str_c(c("", "", "and "), s1, collapse = "")
s_paste_1
s_paste_2
s_str_1 #str_c propogates NA unline paste
s_str_2
```

Let's work on the babynames dataset
```{r}
boy_names_2014 <- filter(babynames,year==2014 & sex=="M")$name
girl_names_2014 <- filter(babynames,year==2014 & sex=="F")$name
str_length(head(boy_names_2014))#length
str_sub(head(boy_names_2014),1,3)#extracting subtrings
str_sub(head(girl_names_2014),-3,-1)#extracting subtrings
```

**Detecting patterns** 

* `str_detect()`- returns a logical vector indicating whether the pattern exists or not
* `str_subset()`- returns only the strings from the vector that contains the pattern
* `str_count()`- returns the number of times a pattern occured in each element of the vector
```{r}
contains_ara <- str_detect(boy_names_2014,pattern = fixed("ara")) #case is important, by default ignore_case is FALSE for fixed
head(boy_names_2014[contains_ara])
str_subset(str_subset(girl_names_2014,pattern=fixed("U")),pattern=fixed("z"))
girl_names_2014[str_count(girl_names_2014,pattern =fixed("a",ignore_case = TRUE))>4]
```

**Splitting strings**

`str_split()`- `simplify`=TRUE will return a matrix, else a list would be returned, `n`- parameter allows the number of splits

```{r}
both_names <- c("Box, George", "Cox, David")
both_names_split <- str_split(both_names,pattern=fixed(", "),simplify=TRUE)
first_names <- both_names_split[,2]
last_names <- both_names_split[,1]
```

**Replacing strings**

`str_replace` and `str_replace_all`
```{r}
phone_numbers <- c("510-555-0123", "541-555-0167")
str_replace(phone_numbers,pattern=fixed("-")," ")

# Use str_replace_all() to replace "-" with " "
str_replace_all(phone_numbers,pattern=fixed("-")," ")
```

### Regular expressions
Regular expressions are a language for desribing patterns. Take the pattern below and its meaning for instance <br/>

`^.[\d]+`- "the start of the string, followed by any single character,
followed by one or more digits" <br/>

The same regex pattern can be obtained using the `rebus` library. The syntax is a bit more verbose but more understandable. Below is the syntax for the same regex using `rebus` : <br/>

```{r}
START %R%
  ANY_CHAR %R%
  one_or_more(DGT)
```

`rebus` provides `START` and `END` shortcuts to specify regular expressions that match the start and end of the string. These are also known as *anchors*. <br/>

The special operator provided by rebus, `%R%` allows you to compose complicated regular expressions from simple pieces. When you are reading rebus code, think of `%R%` as "then".<br/>

`START %R% "c"` - this regex should be interpreted as "the start of a string then a c" <br/>

`str_view()` from `stringr` is really helpful for testing patterns. It will show an html output with the matches highlighted.

```{r}
pattern <- "z" %R% ANY_CHAR

# Find names that have the pattern
names_with_z <- str_subset(boy_names_2014,pattern=pattern)
length(names_with_z)

# Find part of name that matches pattern
part_with_z <- str_extract(boy_names_2014,pattern=pattern)
table(part_with_z)

# Did any names have the pattern more than once?
count_of_z <- str_count(boy_names_2014,pattern=pattern)
table(count_of_z)
# Which babies got these names?
with_z <- str_detect(boy_names_2014,pattern=pattern)

# What fraction of babies got these names?
mean(with_z)
```

### More on regex

Pattern| Regular Expression | rebus
-------|--------------------|---------
Start of a string|^|START
End of a string|$|END
Any single character|.|ANY_CHAR
Literal dot, carat or dollar sign| `"\\."`,`"\\^"`,`"\\$"`|DOT,CARAT,DOLLAR

**Alternation** - This is more like a logical OR, regex `"(dog|cat)"` will capture "dog" or "cat". The `rebus` equivalent of these patterns is the `or` function.<br/>

**Character classes** - Similar to `ANY_CHAR` but with a restricton on what characters are allowed. Regex expressions patterns look like `[Aa]` or `[^Aa]`. The carat inside a class means negated. The `rebus` equivalent functions for these patterns are `char_class()` and `negated_char_class()`. <br/>

**Repititions** - In regex the metacharacters to handle repititions are:

* `?`- optional
* `*`-zero or more
* `+`-one or more
* `{n}{m}`-repeated between n and m times

The `rebus` equivalent functions for these patterns are `optional()`,`zero_or_more`,`one_or_more()`,`repeated()` respectively.<br/>




